main(p) :- p match
  { Program(h, ds) -> {s}
      new s,
      decls(s, ds)
  }.

decls(s, ds) :- ds match
  { []   -> true
  | d:ds -> decl(s, d), decls(s, ds)
  }.

decl(s, d) :- d match
  { Module(x, ds) -> {s_mod}
      new s_mod -> (x, s_mod),
      s -[ `MOD ]-> s_mod,
      s_mod -[ `LEX ]-> s,
      decls(s_mod, ds)
  | Import(r) -> {s_mod}
      mod-ref(s, r),
      false,
      s -[ `IMP ]-> s_mod
  | Def(b) ->
      def-bind(s, b)
  | Rec(x, sup, ds) -> {s_rec}
      new s_rec -> (x, REC(s_rec)),
      s -[ `REC ]-> s_rec,
      super(s, sup, s_rec),
      fld-decls(s, ds)
  }.

super(s, sup, s_rec) :- sup match
  { NoSuper() ->
      true
  | Super(r) -> {s_sup}
      type-ref(s, r),
      false,
      s_rec -[ `EXT ]-> s_sup
  }.

def-binds(s, bs) :- bs match
  { []   -> true
  | b:bs -> def-bind(s, b), def-binds(s, bs)
  }.

def-bind(s, b) :- b match
  { DefBind(x, e) -> {s_var, ty}
      new s_var -> (x, ty),
      s -[ `VAR ]-> s_var,
      expr(s, e, ty)
  | DefBindTyped(x, tyann, e) -> {s_var, ty}
      new s_var -> (x, ty),
      s -[ `VAR ]-> s_var,
      type(s, tyann, ty),
      expr(s, e, ty)
  }.

expr(s, e, ty) :- e match
  { Int(_) ->
      false
  | True() ->
      false
  | False() ->
      false
  | Var(r) ->
      false
  | Add(e1, e2) ->
      expr(s, e1, INT()),
      expr(s, e2, INT()),
      ty == INT()
  | Sub(e1, e2) ->
      expr(s, e1, INT()),
      expr(s, e2, INT()),
      ty == INT()
  | Mul(e1, e2) ->
      expr(s, e1, INT()),
      expr(s, e2, INT()),
      ty == INT()
  | Div(e1, e2) ->
      expr(s, e1, INT()),
      expr(s, e2, INT()),
      ty == INT()
  | And(e1, e2) ->
      expr(s, e1, BOOL()),
      expr(s, e2, BOOL()),
      ty == BOOL()
  | Or(e1, e2) ->
      expr(s, e1, BOOL()),
      expr(s, e2, BOOL()),
      ty == BOOL()
  | Eq(e1, e2) ->
      expr(s, e1, ty),
      expr(s, e2, ty)
  | App(e1, e2) -> {ty1}
      expr(s, e1, FUN(ty1, ty)),
      expr(s, e2, ty1)
  | If(e1, e2, e3) ->
      expr(s, e1, BOOL()),
      expr(s, e2, ty),
      expr(s, e3, ty)
  | Fun(d, e) -> {s_fun, ty1, ty2}
      new s_fun,
      s_fun -[ `LEX ]-> s,
      arg-decl(s, d, ty1),
      expr(s, e, ty2),
      ty == FUN(ty1, ty2)
  | Let(bs, e) -> {s_let}
      new s_let,
      s_let -[ `LEX ]-> s,
      def-binds(s, bs),
      expr(s, e, ty)
  | LetRec(bs, e) -> {s_let}
      new s_let,
      s_let -[ `LEX ]-> s,
      def-binds(s, bs),
      expr(s, e, ty)
  | LetPar(bs, e) -> {s_let}
      new s_let,
      s_let -[ `LEX ]-> s,
      def-binds(s, bs),
      expr(s, e, ty)
  | New(x, bs) -> {recs, xrecs, p}
      query s `REC as recs,
      filter recs ((x', _) where x' == x) xrecs,
      only(xrecs, p),
      false,
      fld-binds(s, bs)
  | FldAccess(e, x) -> {s_rec, flds, xflds, p}
      expr(s, e, REC(s_rec)),
      query s `FLD as flds,
      filter flds ((x', _) where x' == x) xflds,
      only(xflds, p),
      false
  | With(e1, e2) -> {s_with, s_rec}
      expr(s, e1, REC(s_rec)),
      new s_with,
      s_with -[ `EXT ]-> s_rec,
      expr(s_with, e2, ty)
  }.

fld-binds(s, bs) :- bs match
  { []   -> true
  | b:bs -> fld-bind(s, b), fld-binds(s, bs)
  }.

fld-bind(s, b) :- b match
  { FldBind(x, e) -> {ty}
      expr(s, e, ty)
  }.

fld-decls(s, ds) :- ds match
  { []   -> true
  | d:ds -> fld-decl(s, d), fld-decls(s, ds)
  }.

fld-decl(s, d) :- d match
  { ArgDecl(x, tyann) -> {ty}
      type(s, tyann, ty),
      false
  }.

arg-decl(s, d, ty) :- d match
  { ArgDecl(x, tyann) ->
      type(s, tyann, ty)
  }.

type(s, tyann, ty) :- tyann match
  { TInt() ->
      false
  | TBool() ->
      false
  | TArrow(tyann1, tyann2) -> {ty1, ty2}
      type(s, tyann1, ty1),
      type(s, tyann2, ty2),
      ty == FUN(ty1, ty2)
  | TRec(r) -> {s_rec}
      type-ref(s, r),
      ty == REC(s_rec),
      false
  }.

mod-ref(s, r) :- r match
  { ModRef(x) ->
      false
  | ModQRef(r, x) ->
      false
  }.

type-ref(s, r) :- r match
  { TypeRef(x) ->
      false
  | TypeQRef(r, x) ->
      false
  }.

var-ref(s, r) :- r match
  { VarRef(x) ->
      false
  | VarQRef(r, x) ->
      false
  }.
